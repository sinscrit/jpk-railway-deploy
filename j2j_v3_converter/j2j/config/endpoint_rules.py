"""
Endpoint Conversion Rules Configuration

This module centralizes all rules, heuristics, and decision logic used in
JPK-to-JSON endpoint conversion. All rules are designed to be:
- JPK-driven: Use data from JPK files
- Rule-based: Generic heuristics that work for any JPK
- Configurable: Can be adjusted without modifying core conversion logic
- Reviewable: All rules in one place for easy review and maintenance

Date: December 14, 2025
"""

from typing import Dict, List, Any, Optional
from dataclasses import dataclass


# ============================================================================
# ADAPTER NAME MAPPINGS
# ============================================================================

# Proper capitalization for adapter names (used in endpoint naming)
ADAPTER_NAME_MAPPING: Dict[str, str] = {
    'netsuite': 'NetSuite',
    'salesforce': 'Salesforce',
    'tempstorage': 'Temporary Storage',
}

def get_adapter_display_name(adapter_id: str) -> str:
    """
    Get properly capitalized adapter name for endpoint naming.
    
    Rule: Use proper capitalization mapping instead of .title()
    
    Args:
        adapter_id: Lowercase adapter ID (e.g., 'netsuite')
        
    Returns:
        Properly capitalized name (e.g., 'NetSuite')
    """
    return ADAPTER_NAME_MAPPING.get(adapter_id, adapter_id.title())


# ============================================================================
# ENDPOINT TYPE 600 DEDUPLICATION RULES
# ============================================================================

def should_create_new_type_600(adapter_id: str, existing_type_600_map: Dict[str, Dict[str, Any]]) -> bool:
    """
    Determine if a new Type 600 endpoint should be created for an adapter.
    
    Rule: Create only ONE Type 600 endpoint per adapter (deduplication)
    
    Args:
        adapter_id: Adapter identifier
        existing_type_600_map: Map of adapter_id → existing Type 600 endpoint
        
    Returns:
        True if should create new endpoint, False if should reuse existing
    """
    return adapter_id not in existing_type_600_map


def get_type_600_endpoint_id(adapter_id: str, existing_type_600_map: Dict[str, Dict[str, Any]]) -> str:
    """
    Get Type 600 endpoint ID for an adapter (reuse existing or create new).
    
    Rule: Reuse existing Type 600 endpoint ID if adapter already has one
    
    Args:
        adapter_id: Adapter identifier
        existing_type_600_map: Map of adapter_id → existing Type 600 endpoint
        
    Returns:
        Type 600 endpoint ID (existing or new UUID)
    """
    if adapter_id in existing_type_600_map:
        return existing_type_600_map[adapter_id]['id']
    # Will be generated by caller if new endpoint needed
    return None


# ============================================================================
# ENDPOINT METADATA RULES
# ============================================================================

# Adapters that require metadata field
METADATA_REQUIRED_ADAPTERS: List[str] = ['netsuite']

# Entity type IDs for metadata (from baseline analysis)
ENTITY_TYPE_ID_MAPPING: Dict[str, Dict[str, Any]] = {
    'netsuite': {
        'type_500': 18,      # Integer for Type 500
        'type_600': '228',   # String for Type 600
    }
}

def should_add_metadata(adapter_id: str) -> bool:
    """
    Determine if metadata field should be added to endpoint.
    
    Rule: Only NetSuite endpoints require metadata
    
    Args:
        adapter_id: Adapter identifier
        
    Returns:
        True if metadata should be added, False otherwise
    """
    return adapter_id.lower() in METADATA_REQUIRED_ADAPTERS


def create_endpoint_metadata(adapter_id: str, endpoint_type: int) -> Optional[Dict[str, Any]]:
    """
    Create metadata structure for endpoint.
    
    Rule: NetSuite endpoints get metadata with isConnectorFunction, adapterName, entityTypeId
    
    Args:
        adapter_id: Adapter identifier
        endpoint_type: Endpoint type (500 or 600)
        
    Returns:
        Metadata dict or None if not required
    """
    if not should_add_metadata(adapter_id):
        return {}  # Empty metadata for non-NetSuite adapters
    
    adapter_id_lower = adapter_id.lower()
    if adapter_id_lower not in ENTITY_TYPE_ID_MAPPING:
        return {}
    
    entity_type_id = ENTITY_TYPE_ID_MAPPING[adapter_id_lower].get(
        f'type_{endpoint_type}'
    )
    
    if entity_type_id is None:
        return {}
    
    return {
        'isConnectorFunction': True,
        'adapterName': get_adapter_display_name(adapter_id),
        'entityTypeId': entity_type_id
    }


# ============================================================================
# ENDPOINT TYPE RULES
# ============================================================================

# endpointType values for different adapter types
ENDPOINT_TYPE_MAPPING: Dict[str, int] = {
    'netsuite': 600,
    'salesforce': 200,
    'tempstorage': 1000,
}

def get_endpoint_type(adapter_id: str) -> Optional[int]:
    """
    Get endpointType value for Type 600 endpoint.
    
    Rule: Use mapping based on adapter_id
    
    Args:
        adapter_id: Adapter identifier
        
    Returns:
        endpointType value or None
    """
    return ENDPOINT_TYPE_MAPPING.get(adapter_id.lower())


# ============================================================================
# ENDPOINT NAME VALIDATION RULES
# ============================================================================

# Patterns that indicate invalid endpoint names
INVALID_ENDPOINT_NAME_PATTERNS: List[str] = [
    r'^\[.*\]$',  # Variable references like [salesforce_username]
]

def is_valid_endpoint_name(name: str) -> bool:
    """
    Validate endpoint name is not a variable reference or invalid pattern.
    
    Rule: Reject names that match invalid patterns (e.g., variable references)
    
    Args:
        name: Endpoint name to validate
        
    Returns:
        True if valid, False if invalid
    """
    import re
    for pattern in INVALID_ENDPOINT_NAME_PATTERNS:
        if re.match(pattern, name):
            return False
    return True


# ============================================================================
# TYPE 600 ENDPOINT NAMING RULES
# ============================================================================

def get_type_600_endpoint_name(adapter_id: str) -> str:
    """
    Get standard Type 600 endpoint name for an adapter.
    
    Rule: "{AdapterName} Endpoint" using proper capitalization
    
    Args:
        adapter_id: Adapter identifier
        
    Returns:
        Standard endpoint name
    """
    adapter_name = get_adapter_display_name(adapter_id)
    if adapter_id.lower() == 'tempstorage':
        return 'Temporary Storage Endpoint'
    return f"{adapter_name} Endpoint"


# ============================================================================
# ENDPOINT DEDUPLICATION STRATEGY
# ============================================================================

@dataclass
class EndpointDeduplicationStrategy:
    """Strategy for deduplicating Type 600 endpoints."""
    strategy: str  # 'one_per_adapter' or 'per_component'
    description: str

ENDPOINT_DEDUPLICATION_STRATEGY: EndpointDeduplicationStrategy = EndpointDeduplicationStrategy(
    strategy='one_per_adapter',
    description='Create one Type 600 endpoint per adapter, shared by all Type 500 endpoints'
)


# ============================================================================
# HELPER FUNCTIONS FOR RULE APPLICATION
# ============================================================================

def normalize_adapter_id(adapter_id: str) -> str:
    """Normalize adapter ID to lowercase for consistent lookups."""
    return adapter_id.lower() if adapter_id else ''

def get_metadata_for_adapter(adapter_id: str, endpoint_type: int) -> Dict[str, Any]:
    """Get metadata dict for adapter (empty if not required)."""
    metadata = create_endpoint_metadata(adapter_id, endpoint_type)
    return metadata if metadata is not None else {}

